<div class="grid_15 prefix_1" id="language-content">
<a name="language_top"/>
<h1>Javaservices</h1>
<ul>
<li><a href="#language_javaservices_first_javaservice">The first JavaService</a></li>
<li><a href="#language_javaservices_value">Manipulating jolie values in Java</a></li>
<li><a href="#language_javaservices_calling_embedder">Calling an operation of the embedder from the Javaservice</a></li>
<li><a href="#language_javaservices_annotation">Annotations</a></li>
<li><a href="#language_javaservices_requestresponse">Using RequestResponse operations in JavaServices</a></li>
<li><a href="#language_javaservices_dynamic_embedding">JavaService dynamic embedding</a></li>
</ul>
<br><br>
In order to exploit all the programming power of Java, Jolie provides the possibility to integrate Java code into a 
Jolie service by implementing a JavaService. This approach can be particularly useful, e.g., when you need to create a graphical 
user interface or you want to integrate your own Java code into a Service-Oriented Architecture. 
In order to create a JavaService we have to extend the JavaService class, which is in the package <i>jolie.runtime.JavaService</i>, 
and then embedding it into a Jolie service.

<a name="language_javaservices_first_javaservice"/>
<h2>The first Javaservice</h2>
Here we describe the procedure for creating a JavaService by exploiting <a href="http://www.netbeans.org" target="netbeans">Netbeans IDE</a>, 
but you can use the Java developing framework you prefer. 

<h3>Creating a new project</h3>
First of all we need to create a new Java Application project within Netbeans:
<div id="figure">
  <img src="./images/javaservices_netbeans1.jpeg">
  <div id="caption"><b>Figure Javaservices.1</b>: Netbeans project creation mask.
</div>
</div>
Then, we name the project <i>FirstJavaService</i> and we add to its Libraries list the jolie project we have previously
downloaded following the istructions listed in this <a href="#language_install">page</a>. The jolie project contains
the Java declaration of the abstract class <i>JavaService</i> (<i>jolie.runtime.JavaService</i>) we will extend for 
creating our JavaService.

<h3>Creating a new package</h3>
Before writing down the code of our first JavaService, we create the package which will contain it.
<div id="figure">
  <img src="./images/javaservices_netbeans2.jpeg">
  <div id="caption"><b>Figure Javaservices.2</b>: Creation of the package <i>jolie.example</i>.
</div>
</div>

<h3>Creating the Java file</h3>
Then, we create the Java file and we name it with same name of the JavaService that is <i>FirstJavaService</i>.
<div id="figure">
  <img src="./images/javaservices_netbeans3.jpeg">
  <div id="caption"><b>Figure Javaservices.3</b>: Creation of the Java file.
</div>
</div>

<h3>Writing the Java code and building it</h3>
In the following, we create our first JavaService which prints out a message on the console. The Java code follows:
<div id="example" src="example_javaservices_1"/><br>
Finally we can build the Java file into a <i>.jar</i> file.

<h3>Executing the JavaService</h3>
In order to be executed the Javaservice always needs to be embedded by a jolie service which will 
invokes it as a common embedded service as we have described in <a href="#language_embedding">Embedding</a>.
All the public methods of the JavaService can be invoked as they are operations of a Jolie service.
In particular, this example has one public method called <i>write</i> which can be easily invoked
by the following embedder:
<div id="example" src="example_javaservices_2"/><br>
<div id="download">&gt; <a href="./content/code/code_javaservices_1.zip">Download code</a></div>
Note that the embedded construct takes as a type the keyword Java instead of Jolie because we are embedding a JavaService. 
As parameter the embedded construct takes the absolute class name obtained as <i>package_name+class_name</i>.
As for a Jolie service, the embedder must declare the interface of the embedded service and the outputPort used for communicating with it. 
In this case the interface contains a OneWay operation called write whereas the outputPort is called <i>MyFirstJavaServicePort</i>.
It is worth noting that the embedder must be run by passing the JavaService jar file as a parameter by using the option <i>-l</i>
as shown below:
<div id="example" src="example_javaservices_3"/><br>

<a name="language_javaservices_value"/>
<h2>Manipulating jolie values in Java</h2>
So far, we have sent a very simple message to the JavaService that is a string. But, it could be useful to send
an entire Jolie value tree. Before showing the way for accomplishing this issue, we have to introduce the
Java class <i>Value</i>. Such a class allows for the manipulation of Jolie value trees in Java.
<br><br>
<b>Creating a value.</b><br>
First of all, we need to create a Value in Java as we would do in Jolie.
The following Java code creates a Value.
<div id="example" src="example_javaservices_6"/><br>

<b>Getting the vector elements.</b><br>
In each Jolie tree, a node is a vector. In order to access/get the vector elements of a node,
you can use the method <i>getChildren(String subnodeName) </i> which returns the corresponding <i>ValueVector</i>
of the subnode <i>subnondeName</i>. In the following example we get all the vector elements of the subnode
<i>sub_node1</i>.
<div id="example" src="example_javaservices_7"/><br>

In order to access the element at index <i>i</i> it is possible to use the method <i>get(int index)</i>.
In the following example we access the third element of the subnode <i>sub_node1</i>.
<div id="example" src="example_javaservices_8"/><br>
It is worth noting that an element of a ValueVector is a Value and that the first element
of a ValueVector is the element at the index 0.
<br><br>
<b>Getting the value of an element.</b><br>
Once accessed a vector element (a value in general), it is possible to get its value
by simply using one of the following methods depending on the type of the content:
<ul>
  <li>strValue()</li>
  <li>intValue()</li>
  <li>longValue()</li>
  <li>boolValue()</li>
  <li>doubleValue()</li>
</ul>

In the following example we suppose to print out the content of the second element of the subnode 
<i>sub_node1</i> supposing it is a string.
<div id="example" style="font-size:12px;" src="example_javaservices_9"/><br>

<b>Setting the value of an element.</b><br>
Analogously, it is possible to use the method <i>setValue( ... )</i> for setting the value content.


<a name="language_javaservices_calling_embedder"/>
<h2>Calling an operation of the embedder from the Javaservice</h2>
A JavaService can be also programmed for calling an operation of the embedder by using the method <i>sendMessage</i> of the class 
<i>JavaService</i>. Such a feature is particularly useful when we want to create a JavaService which has an active role instead 
of always waiting to be invoked by the mebedder. As an example, we extend the previous JavaService by introducing an invocation of 
a OneWay operation of the embedder called <i>writeBack</i>:
<div id="example" src="example_javaservices_4"/><br>
The class <i>CommMessage</i> (package <i>jolie.net</i>) represents a Jolie communication message which is sent to the embedder by means of the 
JavaService method <i>sendMessage</i>. The method send message indeed requires a message which is created by exploiting the static
methods <i>createRequest</i>. In this case the message has been initialized with the following parameters:
<ul>
<li>"writeBack": the name of the operation of the embedder to call</li>
<li>"/": which specifies the service path (see <a href="#language_redirection">Redirection</a>)</li>
<li>v : which is a Value object that contains the data structure to send.</li>
</ul>
In this case the message to send contains a string: <i>"Hello world from the JavaService!"</i>.
It is worth noting that the class <i>CommMessage</i> provides different static methods for creating
a request message and a response message. In this example we have created a request message because 
the JavaService invokes a OneWay operation of the embedder.
The embedder follows:
<div id="example" src="example_javaservices_5"/><br>
In this case the embedder must declare its own inputPort where it will receive messages from the embedded service. 
The embedder exhibits a OneWay operation called <i>writeBack</i>. In the main procedure the embedder calls the JavaService 
by means of the operation <i>write</i> then waits for a message on the operation <i>writeBack</i>.<br>
<div id="download">&gt; <a href="./content/code/code_javaservices_2.zip">Download code</a></div>

<a name="language_javaservices_annotation"/>
<h2>Annotations</h2>
Each public method programmed within a JavaService must be considered 
as an input operation that can be invoked from the embedder. Depending on the return object the method represents a OneWay 
operation or a RequestResponse one. If the return type is void, the operation is considered a OneWay operation, 
a RequestResponse operation otherwise.
You can override this behaviour by using the @RequestResponse annotation, which forces Jolie to consider the 
annotated method as a RequestResponse operation.


<a name="language_javaservices_requestresponse"/>
<h2>Using RequestResponse operations in JavaServices </h2>
So far, we have exploited only OneWay operations for making interactions between the JavaService and the embedder. 
Now, we present how to exploit also RequestResponse operations. In the example below there are both a RequestResponse 
invocation from the JavaService to the embedder and a RequestResponse invocation from the embedder to the JavaService. 
The Java code follows:
<div id="example" style="font-size:10px;">
package jolie.example;

import jolie.net.CommChannel;
import jolie.net.CommMessage;
import jolie.runtime.JavaService;
import jolie.runtime.Value;
import jolie.runtime.embedding.RequestResponse;

public class ThirdJavaService extends JavaService {

--public void start( Value msg ) {
----System.out.println( msg.getFirstChild("message").strValue() );
----Value v = Value.create();
----v.getFirstChild("message").setValue("Hello world from the Javaservice");
----try {
------CommMessage request = CommMessage.createRequest("initialize","/",v);
------CommMessage response = sendMessage( request ).recvResponseFor( request );
------System.out.println( response.value().strValue() );	
----}
----catch ( Exception e ) {
------e.printStackTrace();
----}
--}

--@RequestResponse
--public Value write( Value msg ){
----System.out.println( msg.getFirstChild("message").strValue());
----Value v = Value.create();
----v.getFirstChild("message").setValue("Hello world from the write operation of the JavaService!");
----return v;
--}
}
</div>
In this example, the JavaService exhibits a OneWay operation <code>start</code> where it prints out 
the received message and then invokes the embedder by means of the RequestResponse operation <code>initialize</code>. 
The RequestResponse invocation is performed by means of the method <code>sendMessage</code> where the string 
<code>"Hello world from the Javaservice"</code> is the message content. Since, we are calling a RequestResponse
we must wait for receiving the response message by means of the methods <code>recvResponseFor</code> which returns
the response message stored into the variable <code>response</code>.
Moreover, the JavaService exhibits 
the RequestResponse operation <code>write</code> where it prints out the received message and returns the string 
<code>"Hello world from the write operation of the JavaService!"</code>. It is worth noting that the exhibited RequestResponse 
operation returns a Value object which contains the response message.
The code of the embedder follows:
<div id="code" src="javaservices/requestresponse/embedder.ol"/>
It is worth noting that the JavaService interface declares both the OneWay operation <code>start</code>
and the RequestResponse <code>write</code>. Moreover, the embedder exhibits a RequestResponse operation called <code>initialize</code>. 
In the behaviour, the embedder calls the operation <code>start</code> of the JavaService and then waits for a message on the operation 
<code>initialize</code>. At the end, the embedder invokes the operation <code>write</code> of the JavaService. 
Here we provide the code to be downloaded. In the zip file we also provide the prebuilt jar file of the 
javaservice, thus it is possible to execute the embedder by specifying the jar to be used in the command line
as it follows:
<div id="example">jolie embedder.ol -l Example3.jar</div>
<div id="download">&gt; <a href="./content/code/code_javaservices_3.zip">Download code</a></div>
<br><br>
<b>Managing fault responses</b><br>
In Jolie a RequestResponse message can return a fault message which must be managed into the Javaservice.
Now, let us suppose to modify the <code>embedder.ol</code> by throwing the fault <code>MyFault</code> as response into the body of
the <code>initialize</code> operation as it follows:
<div id="code">
initialize( request )( response_initialize ){
    scope( myScope ) {
      install( MyFault => println@Console("Fault raised!")() );
	  response_initialize = "This is the initialization";
	  throw( MyFault )
    }
};
</div>
Clearly, we have also to enhance the interface in order to declare that operation <code>initialize</code>
can raise a fault as shown below:
<div id="code">
interface EmbedderInterface {
RequestResponse:
	initialize throws MyFault
}
</div>
After enabling fault raising into <code>embedder.ol</code>, we simply modify the JavaService by checking
if the response is a fault or not by exploiting method <code>isFault</code> of the class <code>CommMessage</code>
as we do in the following Java code:
<div id="example" style="font-size:12px;">
CommMessage response = sendMessage( request ).recvResponseFor( request );
if ( response.isFault() ) {
--System.out.println( response.fault().faultName() );
} else {
--System.out.println( response.value().strValue() );
}
</div>

<a name="language_javaservices_dynamic_embedding"/>
<h2>JavaService dynamic embedding</h2>
So far, we have discussed the possibility to statically embed a JavaService. 
In this case the JavaService is shared among all the sessions created by the embedder. 
It could be particulary suitable to embed a different JavaService for each embedder session. 
Such a task can be fulfilled by exploiting dynamic embedding functionality supplied by the 
<code>runtime</code>. In the following example we present the Java code of a JavaService
which simply returns the value of a counter which is increased each time it is invoked
on its method <code>start</code>.
<div id="example">
public class FourthJavaService extends JavaService {	
--private int counter;
--public Value start( Value request ) {
----counter++;
----Value v = Value.create();
----v.setValue( counter );
----return v;
--}
}
</div>
Now we dynamically embed this JavaService in the following service where for each
session opened on operation <code>run</code> the JavaService is dynamically embedded and called
on the operation <code>start</code>
<div id="code" src="javaservices/dynamicbinding/embedder_dynamic.ol"/>
If we create a simple client which calls this service for ten times we will have
the following result on the console:
<div id="example">Received counter 1
Received counter 1
Received counter 1
Received counter 1
Received counter 1
Received counter 1
Received counter 1
Received counter 1
Received counter 1
Received counter 1
</div>
Such a result means that for each session enabled on the embedder, a new JavaService object is instantiated
and executed. Indeed, we can try to execute the same client on a embedder service which statically
embed the JavaService, the result will be:
<div id="example">Received counter 1
Received counter 2
Received counter 3
Received counter 4
Received counter 5
Received counter 6
Received counter 7
Received counter 8
Received counter 9
Received counter 10
</div>
In this case the JavaService is shared among all the sessions and each new invocation will increase 
its inner counter. In the following you can download the code and try yourself.
<div id="download">&gt; <a href="./content/code/code_javaservices_4.zip">Download code</a></div>
</div>