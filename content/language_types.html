<div class="grid_15 prefix_1" id="language-content">
<a name="language_top"/>
<h1>Types</h1>
<ul>
<li><a href="#language_types_native_types">Native types</a></li>
<li><a href="#language_types_complex_types">Complex types</a>
  <ul>
    <li><a href="#language_types_sub_types">Sub types</a></li>
  </ul>
</li>
<li><a href="#language_types_cardinality">Cardinality</a></li>
<li><a href="#language_types_faults">Type declaration in faults</a></li>
<li><a href="#language_types_type_mismatch">Type mismatching</a>
  <ul>
     <li><a href="#language_types_type_mismatch_one_way">Type mismatching in OneWay operations</a>      
     <li><a href="#language_types_type_mismatch_request_response">Type mismatching in RequestResponse operations</a> 
     <li><a href="#language_types_type_mismatch_fault">Type mismatching in fault messages</a> 
  </ul>
</li>

</ul>
<br>
In Jolie, types allow for a precise definition of service interfaces. 
They are used for defining input and output message format, but they are not used for defining behaviour variable types.

<a name="language_types_native_types"/>
<h2>Native types</h2>
&gt; <a href="#language_top">Go on top</a>
<br>
In Jolie there are the following native types:
<br><br>
<ul>
    <li>string</li>
    <li>int</li>
    <li>long</li>
    <li>double</li>
    <li>bool</li>
    <li>raw</li>
    <li>void</li>
    <li>any</li>
</ul>
<br>
<h3>raw</h3>
The native type raw defines a byte array content.

<h3>void</h3>
The native type void defines a value content which <b>must be</b> empty.

<h3>any</h3>
The native type any defines a value content which can be any native type.
<br>
<br>
In the following example we show how to declare an interface where messages 
are all defined by means of native types. 
<div id="example" src="example_types_1"/>


<a name="language_types_complex_types"/>
<h2>Complex types</h2>
&gt; <a href="#language_top">Go on top</a>
<br><br>
Now, let us start to create complex types. In Jolie it is possible to create 
a type by means of the keyword type whose syntax follows:
<div id="syntax" src="syntax_types_1"/>
<i>type_name</i> is the identifier of the type, <i>native_type</i> represents the native type of the 
root element and <i>SubTreeDeclaration</i> represents all the sub-elements contained in the type.
In the following example we define the type <i>myType</i> whose value must be a string and its subelements 
are <i>subel1</i> and <i>subel2</i> which must be a int and a double respectively:
<div id="example" src="example_types_2"/>
It is worth noting that sub-elements are always prefixed by symbol " . " .
Now, let us introduce an interface for specifying type <i>myType</i> for operation message:
<div id="example" src="example_types_3"/>

<a name="language_types_sub_types"/>
<h3>Sub types</h3>
Sub-elements can have their own type which can be:
<ul>
    <li>the id of another declared type</li>
    <li>a new type </li>
</ul>
In the following we enrich the type declaration of the previous example in order to join a type to sub-elements <i>x</i> and <i>y</i>. 
We assign the type <i>mySubType</i> to <i>x</i> whereas we declare a subtype for <i>y</i>:
<div id="example" src="example_types_4"/>
The symbol <b>{ ? }</b> allows for the definition of a subtype which can contain any sub-element.

<a name="language_types_cardinality"/>
<h2>Cardinality</h2>
&gt; <a href="#language_top">Go on top</a>
<br><br>
When defining subelements in a type it is also possible to express their cardinality. 
In other words, it is possible to define the minimum and/or the maximum number of occurrences of the same sub-element. 
When the symbol <b>*</b> is used for defining the maximum occurence, it represents an infinite boundary.
Some shortcutus can be exploited for defining the cardinality:
<ul>
  <li>* stands for [ 0, * ]</li>
  <li>? stands for [ 0, 1 ]</li>
</ul>
If cardinality is not defined it stands for [ 1 , 1 ].<br>

In the following example we report a type where subelements have different cardinalities.
<div id="example" src="example_types_5"/>
<ul>
  <li>Sub-element <i>x</i> has been defined with minimum one occurence and no infinite maximum boundary.</li>
  <li>Sub-element <i>y</i> has been defined with minimum one occurence and maximum three.</li>
  <li>Sub-element <i>value</i> has been defined with minimum zero occurences and infinite maximum boundary.</li>
  <li>Sub-element <i>comment</i> has been defined with minimum one occurences and maximum one.</li>
  <li>Sub-element <i>z</i> has been defined with minimum zero occurences and maximum one.</li>
<br>

<a name="language_types_faults"/>
<h2>Type declaration in faults</h2>
&gt; <a href="#language_top">Go on top</a>
<br><br>
Types can also be defined for fault messages. The definition is very simple and it is similar
to that of normal request and response messages. In the following we report a simple example:
<div id="example" src="example_types_6"/>

<a name="language_types_type_mismatch"/>
<h2>Type mismatching</h2>
&gt; <a href="#language_top">Go on top</a>
<br><br>
When a message does not match the related type a <i>TypeMismatch</i> fault is raised by the interpreter.
The TypeMismatch fault can be handled by exploiting fault handlers as usual. 
The fault description can be retrieved by accessing the TypeMismatch fault node as described in the 
<a id="navlink_redirection" href="#language_fault_handling">Fault Handling</a> session:
<div id="example" src="example_types_7"/>

<a name="language_types_type_mismatch_one_way"/>
<h3>Type mismatching in OneWay operations</h3>
In case a OneWay operation is used, a TypeMismatch check is performed:
<ul>
    <li>on the sender side, when the message is sent out to the other service</li>
    <li>on the receiver side, when a message is received from another service </li>
</ul>
In the former case the sender will check if the output message matches with the type declared in the corresponding outputPort. 
If the message does not match a TypeMismatch fault is raised and the message is not sent.
In the latter case, the interpreter will check if the incoming message checks with the corresponding inputPort type. 
If not, the message is not received and a TypeMismatch warning will be printed out on the console.
<br><br>
<b>IMPORTANT:</b>
It is worth noting that in case of OneWay, the receiver will not raise a TypeMismatch fault as a response.
A message which does not match the type declared for an inputPort will be automatically discarded and it will 
not affect the behaviour service sessions.
If a message is correctly sent by the sender but it will not match the type declaration on the receiver side, 
the sender will not be notified with a fault message.

<a name="language_types_type_mismatch_request_response"/>
<h3>Type mismatching in RequestResponse operations</h3>

If a RequestResponse is used, different behaviours are considered in case of a TypeMismatch.
<ul>
<li><i>sender side-request message:</i>
If a message type does not match with the declared type on the sender side when the request message is sent:
    <ul>
      <li>the message is not sent</li>
      <li>a TypeMismatch fault is raised. </li>
    </ul>
</li>

<li><i>receiver side-request message:</i>
If a message type does not match with the declared type on the receiver side when the request message is received:
    <ul>
      <li>the message is discarded</li>
      <li>a warning is printed out on the console</li>
      <li>a TypeMismatch fault is sent back to the sender which is waiting for a response.</li>
    </ul>
</li>

<li><i>receiver side-response message:</i>
If a message type does not match with the declared type on the receiver side when the response message is sent:
  <ul>
    <li>a TypeMismatch fault is raised on the receiver side</li>
    <li>a TypeMismatch fault is sent to the sender </li>
  </ul>
</li>

<li><i>sender side-response message:</i>
If a message type does not match with the declared type on the sender side when the response message is received:
  <ul>
    <li>a TypeMismatch fault is raised on the sender side </li>
  </ul>
</li>
</ul>

<a name="language_types_type_mismatch_fault"/>
<h3>Type mismatching in RequestResponse operations</h3>

</div>